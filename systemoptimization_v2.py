# -*- coding: utf-8 -*-
"""SystemOptimization_v2.ipynb

Automatically generated by Colaboratory.

Original file is located at
"""

##INPUTS
#Loads data: hourly prices, demand charges, load values, solar generation 
#Imports Libraries
import random
import pandas as pd
import numpy as np
import time
import scipy.optimize as optimize
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import LogNorm 
import requests
import random
import plotly.express as px
from scipy.optimize import LinearConstraint
from scipy.optimize import SR1
from scipy.optimize import minimize
from google.colab import files
import io 
import itertools 

########
########   TO DO
########
# from google.colab import drive
# drive.mount('/content/gdrive')
# df1 = pd.read_csv('gdrive/My Drive/Colab Data/solar_generation.csv')

random.seed(237)
df1 = pd.read_csv('')
# data_to_load = files.upload()


# data_to_load_2=files.upload()

# df2Temp

url = '###'
# url='http:///get_rate_by_oid/?oid=5b5e44e15457a33a3a26b8fb'
res = requests.get(url).json()
kwh_rates = []
kw_rates = []
for r in res['rate_time_series']:
  kwh_rates.append(r['kwh_rate'])
  kw_rates.append(r['kw_rate'])

rates = kwh_rates
#Large office load shape. 1MW average
load = df1['load']
load_array=np.array(load)
cum_load_array=np.zeros((len(load_array)))
for row in range(len(load_array)):
  cum_load_array[row]=np.sum(load_array[:row])

init_cols = ['solar', 'rates', 'load', 'generation']
df = pd.DataFrame(columns=init_cols)

#Solar generation profile is from Helioscope, scaled to 1 kW
df['solar'] = df1['solar_kwh']

df.loc[:, 'datetime'] = pd.date_range(start='1/1/2019', periods=8760, freq="H")
df = df.set_index(pd.DatetimeIndex(df['datetime']).date)
df['datetime'] = pd.to_datetime(df['datetime'])

df = df.set_index(df['datetime'])
# df.loc[:, 'kwh_rate'] = kwh_rates
# df.loc[:, 'kw_rate'] = kw_rates

#To run examples, modify profiles and rates here
# df.loc[:,'kwh_rate']=df['kwh_rate']
# df.loc[:,'kw_rate']=df.loc['kw_rate']

df.loc[:,'solar'] = df.loc[:, 'solar']
df['load'] = df1['load'].values
print(df['load'].describe())
print(df1['load'].describe())

# df2Temp.loc[:, 'load'].head()
df.head()

#To run examples, modify profiles and rates here
print(df2Temp)
df.loc[:,'kwh_rate']= 0.16
df.loc[:,'kw_rate']=0
# df.loc[:,'solar'] = df['solar']
# df.loc[:,'load'] = df2Temp['load']

"""# New Section"""

# General parameters used throughout
discountrate = 0.06
term = 25
FuelCellCapacityFactor=0.94
chp_capacity_factor = .6
# CO2cost in USD/ton, https://www.epa.gov/sites/production/files/2016-12/documents/social_cost_of_carbon_fact_sheet.pdf
CO2cost=52
# Cost scaling factors
# Base Costs (1kW):
# Solar= 2,102 USD/1kW
# Fuel Cell= 10,372 USD/1kW
# CHP= 3,993 USD/1kW
Solar_Cost_Scaling=0.8
FC_Cost_Scaling=1
CHP_Cost_Scaling=1
imports_penalty_factor = 0.1
#Specify net metering compensation relative to retail rate of electricity (1 = 100% of the price)
Net_metering_compensation=1 #Not implemented yet!! Is it worth it?
#Specify net metering cap relative to annual load (1=100% of compensation up to the annual load)
Net_metering_cap=1
#For resilience flag, max battery discharge depth
Max_Battery_Discharge_resilience=0.2

# Set to 1 if yes, 0 if no.
# On site generation charging constraint for battery
Limit_OnSiteGenOnly=0
# Optimize considering emissions social cost
Count_Emissions_cost=0
# Optimize considering penalty factor for imports and battery discharge max
resiliency_flag = 0
# Consider net metering policy
NetM_flag=1

# GENERATION OPTIMIZATION

# Define functions
# Goes through gen arrays and makes sure there are no negative values (replaces with 0)
# Assigns random hourly values to PV generation
# Assigns capacity value as gen value for fuel cells
# Totalizes gen
def format_generation(pv_kw, fuel_cell_kw, chp_kw): 
	if pv_kw <= 0:
		pv_kw = 0
	if fuel_cell_kw <= 0:
		fuel_cell_kw = 0
	if chp_kw <= 0:
		chp_kw = 0

	df.loc[:, 'pv_generation'] = df.loc[:, 'solar'] * pv_kw
	df.loc[:, 'fuel_cell_generation'] = float(fuel_cell_kw)*FuelCellCapacityFactor
	df.loc[:, 'chp_generation'] = float(chp_kw) * chp_capacity_factor
	df.loc[:,'generation'] = df.loc[:,'pv_generation'] + df.loc[:,'fuel_cell_generation'] + df.loc[:,'chp_generation']
	return df.loc[:,'generation'].values

#Calculates baseload as mean of 50 smaller values
def get_baseload(load):
	sorted_list = np.sort(load)
	load_sum=0
	counter=0
	for i in range (0,50):
	  load_sum=load_sum+np.array(sorted_list)[i]
	  counter=counter+1
	baseload= load_sum/counter
	return baseload

#Calculates demand savings
#Selects peak hour of the month and calculates demand reduction, then equates savings
def get_demand_savings(load, generation):
	net_load = []
	df.loc[:, 'net_load'] = df.loc[:, 'load'] - df.loc[:, 'generation']

	m = df.groupby(pd.Grouper(freq='M'))
	max_demand = m.max()
	average_peak_demand_charge = df.loc[m.idxmax()['net_load'], 'kw_rate'].mean()
	kw_billed_before = np.max(max_demand.loc[:, 'load'].sum(),0)
	kw_billed_after = np.max(max_demand.loc[:,'net_load'].sum(),0)

	# max_demand['demand_reduction'] = max_demand['load'] - max_demand['net_load']

	demand_savings = (kw_billed_before - kw_billed_after) * average_peak_demand_charge
	return demand_savings

#Calculates NPV with system sizes as inputs
#No escalation, nor degradation
#Discount rate=6%, Term=25 years
rows_list = []
environmental = Count_Emissions_cost
def calculate_npv(params):
	resul=0
	a_solar, d_fuel_cell_kw, c_chp_kw = params
	pv_kw = a_solar
	fuel_cell_kw = d_fuel_cell_kw
	chp_kw = c_chp_kw

	savings = 0
	
	grid_import_cost = 0
	generation = format_generation(pv_kw, fuel_cell_kw, chp_kw) 
	
	global NetM_flag
	#Using np arrays for speed
	
	gen_array=np.array(generation)
	temp_len=len(gen_array)
	cum_gen_array=np.zeros((temp_len))
	cum_gen_array[0]=gen_array[0]
	for row in range(1,temp_len):
		cum_gen_array[row]=gen_array[row]+cum_gen_array[row-1]
	
	for index, val in enumerate(load):
		if NetM_flag == 1:
			if (cum_load_array[index]*Net_metering_cap)>cum_gen_array[index]:
				savings += (generation[index] * rates[index])
			if generation[index]<val:
				grid_import_cost += (val - generation[index]) * rates[index]

		if NetM_flag == 0:
			#If generation is greater than the load, only consider the generation up to the load, no excess
			if generation[index] > val:
				savings += val * rates[index] # add savings up to the load, but throw out the excess
			else:
				# add savings for the full generation because the load can handle it
				savings += (generation[index] * rates[index])
				grid_import_cost += (val - generation[index]) * rates[index]

	demand_savings = get_demand_savings(load, generation)
	savings += demand_savings
	# offset = sum(generation) / sum(load)
	total_cost = get_system_costs(params)
 
	global environmental
 
	if environmental == 1:
		# Include technologies as more emitting tech is added
		# Emissions FC= 884 pounds per MWh https://www.greentechmedia.com/articles/read/blooms-fuel-cells-just-how-green-is-a-bloom-box
		# Metric ton = 2204.62 pounds
		emissions_cost_fc = fuel_cell_kw * 8.760 * FuelCellCapacityFactor * 884 * CO2cost / 2204.62
		emissions_cost_chp = chp_kw * 8.760 * chp_capacity_factor * 884 * CO2cost / 2204.62
		total_emissions_cost = emissions_cost_fc + emissions_cost_chp
		savings -= total_emissions_cost

	if resiliency_flag == 1:
		savings -= grid_import_cost * imports_penalty_factor
		
	if savings > 0 and total_cost > 0:
		pv = savings * ((1.0-(1.0/((1.0+discountrate)**float(term))))/discountrate)
		resul = pv - total_cost
		rows_list.append(
				{'Solar':pv_kw, 'Fuel Cell':fuel_cell_kw, 'CHP':chp_kw, 'NPV':resul}
		)
		return -1*resul
	else:
		return 0

#Calculates system costs
def get_system_costs(params):
	a_solar, d_fuel_cell_kw, c_chp_kw = params
	pv_kw = a_solar
	fuel_cell_kw = d_fuel_cell_kw
	chp_kw = c_chp_kw

	pv_cost = solar_cost_function(pv_kw)
	fuel_cell_cost = fuel_cell_cost_function(fuel_cell_kw)
	chp_cell_cost = chp_cost_function(chp_kw)
	return (pv_cost + fuel_cell_cost + chp_cell_cost)

#Calculates solar costs based on system size
def solar_cost_function(pv_kw):
	if pv_kw < 0.589113:
	  cost_per_kw = -14*pv_kw + 3400
	else:
		cost_per_kw = np.minimum(-173.4*np.log(pv_kw)+3300.2, 2930)
	
	global Solar_Cost_Scaling
	return 2500*pv_kw #cost_per_kw * pv_kw * Solar_Cost_Scaling

#Calculates FC costs based on system size
def fuel_cell_cost_function(fuel_cell_kw):
	if fuel_cell_kw < 0.0946785:
		fc_cost_per_kw = -333.33* fuel_cell_kw + 15000
	else:
		fc_cost_per_kw = np.minimum(-496.1*np.log(fuel_cell_kw) + 13799, 12000)
	global FC_Cost_Scaling
	return fc_cost_per_kw * fuel_cell_kw * FC_Cost_Scaling

#Calculates FC costs based on system size
def chp_cost_function(chp_kw):
	if chp_kw < 0.0946785:
		chp_cost_per_kw = -333.33* chp_kw + 4500
	else:
		chp_cost_per_kw = np.minimum(-np.log(chp_kw) + 4000, 4500)
	return chp_cost_per_kw * chp_kw * CHP_Cost_Scaling
	
bnds = ((0,load.mean()*3), (0,load.values.sum()*2/8760), (0,load.values.sum()*2/8760))
def opt():
	init_fuel_cell_kw = get_baseload(load.values)
	init_chp_kw = get_baseload(load.values)
	init_pv_kw = sum(load.values) / 8760
	x0 = np.array([init_pv_kw, init_fuel_cell_kw, init_chp_kw])
	start_time = time.time()
	# res = optimize.differential_evolution(calculate_npv, bounds=bnds, disp=True, args=(Count_Emissions_cost))
	res = optimize.differential_evolution(calculate_npv, bounds=bnds, disp=True)
	end_time = time.time()
	return res

res = opt()

#Visualize optimization iterations

# import plotly.express as px 
# import plotly.io as pio
# plot = pd.DataFrame(data=rows_list)
# fig = px.scatter_3d(plot, x='Solar', y='Fuel Cell', z='NPV', color='NPV', template='plotly_dark')
# fig.show()

exports = 0
idx = 0

#optimal_generation = format_generation(res.x[0], res.x[1], res.x[2])
optimal_generation = format_generation(50,0,70)

while idx < len(optimal_generation):
  if optimal_generation[idx] > load[idx]:
    exports += -(load[idx] - optimal_generation[idx])
  idx += 1

print("------Optimization Results------")
# print("Optimal PV kW: ", res.x[0])
# print("Optimal Fuel Cell kW: ", res.x[1])
# print("Optimal CHP kW: ",res.x[2] )
# print("Net Present Value: ", -round(res.fun,2))

print("Optimal PV kW: ", 50)
print("Optimal Fuel Cell kW: ", 0)
print("Optimal CHP kW: ",70 )
parameters = np.array([50, 0, 70])
print("Net Present Value: ", calculate_npv(parameters))

offset = 0

def get_offset(generation, load):
  offset = 0 # percent
  exports = 0 # kwh quantity
  for idx, gen in enumerate(generation):
    if gen > load[idx]:
      exports += gen

  if NetM_flag == 0:
    # net metering not allowed
    offset = (sum(optimal_generation) - exports)/sum(load)*100
  else:
    # net metering allowed
    offset = (sum(optimal_generation))/sum(load)*100
  return offset

offset = get_offset(optimal_generation, load) #percentage
print(str(offset)+"%")
plt.show()

#See typical load profiles (before-after)
plt.title("Optimal Scenario")
optimal_generation = format_generation(res.x[0], res.x[1], res.x[2]) 
plt.plot(optimal_generation[6850:7050], label='Optimal Generation')
plt.plot(load.values[6850:7050], label='Original Load')
plt.legend()
plt.show()

#Battery Optimization

#Run after finding system sizes

#Calculates Daily Battery Savings based on generation profile and energy/demand Charges

def batteryDailySavings(batteryGen, demand_charge, energyPrices,hourlyLoad):
  batteryGenProfile = batteryGen
  hrLoad=np.array(hourlyLoad)
  newload = np.zeros(24)
  #Payments received from the battery's perspective are positive
  energyRevenue = 0
  OriginalDemandCharge=0
  NewDemandCharge=0
  for hr in range(0,24):
    newload[hr] = hrLoad[hr] - batteryGenProfile[hr]
    if batteryGenProfile[hr]>0:
      energyRevenue += batteryGenProfile[hr]*(1-Losses)*energyPrices[hr]
    else:
      energyRevenue += batteryGenProfile[hr]*(1+Losses)*energyPrices[hr]

    if (newload[hr]*(demand_charge[hr]/(365/12)))>NewDemandCharge:
      NewDemandCharge=(newload[hr]*(demand_charge[hr]/(365/12)))
    
    if (hrLoad[hr]*(demand_charge[hr]/(365/12)))>OriginalDemandCharge:
      OriginalDemandCharge=(hrLoad[hr]*(demand_charge[hr]/(365/12)))

  energySavings = np.sum(energyRevenue)
  demandSavings = OriginalDemandCharge - NewDemandCharge
  return -(energySavings + demandSavings)

tempdf=df
tempdf=tempdf.groupby([tempdf.datetime.dt.month, tempdf.datetime.dt.hour]).mean()

def BatteryAnnualSavings(dataframe, BatteryOutputCap, BatteryTankCap, LossesFact, LimitToOnSiteGen):
  #Assigning inputs to local variables
  BatteryOutput=np.float(BatteryOutputCap)
  BatteryTankCapacity=np.float(BatteryTankCap)
  Losses=np.float(LossesFact)

  tempdf=dataframe
  tempdf['optimal_generation']=optimal_generation
  tempdf=tempdf.groupby([tempdf.datetime.dt.month, tempdf.datetime.dt.hour]).mean()

  #Use numpy as inputs
  #Define these before!!!
  hrLoad = np.zeros(24)
  hrPrices = np.zeros(24)

  BatteryTankArray = np.zeros(24*365)
  BatteryOutputArray = np.zeros(24*365)

  demand_charge = df.loc[:, 'kw_rate'][0*24: 24 + (0 * 24)]
  #Not sure that the Hessian is zero everywhere.
  hessFunc = lambda x, v:np.zeros((24,24))


  
  # loop through days in a year, running an optimization for each day. Append to list and return JSON
  
  batteryAnnualSav=0
  Months=[12,1]

  for month in Months:

    tempmonthdf = tempdf.loc[month]
    hrLoad = np.array(tempmonthdf['load'])
    hrOptimalGen=np.array(tempmonthdf['optimal_generation'])
    demand_charge = np.array(tempmonthdf['kw_rate'])
    energyPrices= np.array(tempmonthdf['kwh_rate'])

    #InitialBatteryValues
    tempBatteryGen = np.full(24,-BatteryOutput/2)
  
    # looking into annealing

    #Constraints:
    #DailyLimitArray
    ZerosArray = np.full(24,0)
    global resiliency_flag
    if resiliency_flag ==1:
      InitialTank=BatteryTankCapacity*Max_Battery_Discharge_resilience
    else:
      InitialTank=np.float(0)
    BatteryTankmin = np.full(24,InitialTank) #Tank "empty" at first
    BatteryTankMax = np.full(24,BatteryTankCapacity)
    BatteryOutputmin = np.full(24,-BatteryOutput)
    BatteryOutputMax = np.full(24,BatteryOutput)

    #Considers On-site gen restriction
    global Limit_OnSiteGenOnly
    if LimitToOnSiteGen==1:
      for row in range (len(BatteryTankMax)):
        if hrOptimalGen[row]*-1>-BatteryOutput:
          BatteryOutputmin[row]=hrOptimalGen[row]*-1

    minCons = np.concatenate((BatteryOutputmin, BatteryTankmin))
    MaxCons = np.concatenate((BatteryOutputMax, BatteryTankMax))

    #TankConstraints Matrix // DESIGNED FOR DAILY OPT
    TankConMa=np.zeros((24, 24))
    for row in range (0, 24):
      column=0
      while column<=row:
        TankConMa[row,column]=-1
        column+=1

    CenterMatrix = np.concatenate((np.identity(24), TankConMa))

    constraint_output=LinearConstraint(CenterMatrix,minCons,MaxCons)

    batt_opt = minimize(batteryDailySavings, tempBatteryGen, method='trust-constr', 
                        constraints = [constraint_output], args=(demand_charge,energyPrices,hrLoad), 
                        tol=1e-5, options={'maxiter':5000})
    

    vectorResult = batt_opt.x
    monthDailySaivings=batteryDailySavings(vectorResult,demand_charge,energyPrices,hrLoad)
    batteryAnnualSav+=(monthDailySaivings*-1)
    print('Done month',month)
  
  return (batteryAnnualSav/len(Months))*365

#Battery Parameters
BatteryBaseInv=df.load.mean()
BatteryOutput = np.float(BatteryBaseInv)
Losses = np.float(0.04)
BatteryCost = np.float(800)

#Defining different durations to be considered
BatteryTankCapacities=[BatteryOutput*1,BatteryOutput*2,BatteryOutput*4, BatteryOutput*6]

#Comparing Options
#Considering durations first
AnnualSavingsValue=0
BestNPV=0
BestDuration=0
discountrate = 0.06
term=25
for tankcap in BatteryTankCapacities:
  tempAnnualSav=BatteryAnnualSavings(df,BatteryOutput,tankcap,Losses,Limit_OnSiteGenOnly)
  tempPVRevenue = tempAnnualSav*((1.0-(1.0/((1.0+discountrate)**float(term))))/discountrate)
  tempNPV = tempPVRevenue - (tankcap*BatteryCost)
  if tempNPV>BestNPV:
    AnnualSavingsValue=tempAnnualSav
    BestNPV=tempNPV
    BestDuration=tankcap/BatteryOutput

print('Best Configuration (1)=',' ','Annual Savings=',AnnualSavingsValue,'  ','Duration=',BestDuration)

#Defining different inverter sizes to be considered
BestInverter=BatteryBaseInv
BatteryOutputAlt=[BatteryBaseInv*1.5,BatteryBaseInv/2, BatteryBaseInv*2]
BestNPVinv=BestNPV
for invAlt in BatteryOutputAlt:
  tempAnnualSav=BatteryAnnualSavings(df,invAlt,BestDuration*invAlt,Losses,Limit_OnSiteGenOnly)
  discountrate = 0.06
  term=25
  tempPVRevenue = tempAnnualSav*((1.0-(1.0/((1.0+discountrate)**float(term))))/discountrate)
  tempNPV = tempPVRevenue - (BestDuration*invAlt*BatteryCost)
  if tempNPV>BestNPVinv:
    AnnualSavingsValue=tempAnnualSav
    BestNPVinv=tempNPV
    BestInverter=invAlt

print('BestConfiguration (2)=',' ','AnnualSavings=',AnnualSavingsValue,' ','Inverter=', BestInverter,' ','Duration=',BestDuration,' ', 'NPV=',BestNPVinv)

#Example, to run a specific interval
#Battery Optimization
print('BestConfiguration (2)=',' ','AnnualSavings=',AnnualSavingsValue,' ','Inverter=',BestInverter,' ','Duration=',BestDuration)
InternalRR=np.irr(np.concatenate((np.array([-BestInverter*BestDuration*BatteryCost]),np.full(term,AnnualSavingsValue))))
# Payback is not discounted!! Same we use in the general proforma
SimplePayback=(BestInverter*BestDuration*BatteryCost)/AnnualSavingsValue
print('BestNPVinv=',BestNPVinv,' ','BestIRR=',InternalRR,'BestPayback=',SimplePayback)

NetLoad = np.array(df['load'])-optimal_generation


BatteryGen = np.zeros(365 * 24)
BatteryTank = np.zeros(365 * 24)

#Battery Parameters
BatteryOutput = BestInverter
BatteryTankCapacity = BestDuration*BestInverter
Losses = np.float(0.04)


#Use numpy as inputs

#Define these before!!!
hrLoad = np.zeros(24)
hrPrices = np.zeros(24)

BatteryTankArray = np.zeros(24*365)
BatteryOutputArray = np.zeros(24*365)

demand_charge = df.loc[:, 'kw_rate'][0*24: 24 + (0 * 24)]
#Not sure that the Hessian is zero everywhere.
hessFunc = lambda x, v:np.zeros((24,24))


  
# loop through days in a year, running an optimization for each day. Append to list and return JSON
# def optimize_battery():
for day in range (200,202):
  tempNetLoad = NetLoad[(day*24):((day+1)*24)]
  hrLoad = np.array(tempNetLoad)
  tempHrPrices = df.loc[:, 'kwh_rate'][day*24: 24 + (day*24)]
  hrPrices = np.array(tempHrPrices)
  tempBatteryGen = np.full(24,-BatteryOutput/2)

  demand_charge = df.loc[:, 'kw_rate'][day*24: 24 + (day * 24)].values

  # looking into annealing

  #Constraints:
    #DailyLimitArray
  ZerosArray = np.full(24,0)
  InitialTank=np.float(0)
  BatteryTankmin = np.full(24,InitialTank) #Tank empty at first
  BatteryTankMax = np.full(24,BatteryTankCapacity)
  BatteryOutputmin = np.full(24,-BatteryOutput)
  BatteryOutputMax = np.full(24,BatteryOutput)

  #Considers On-site gen restriction
  if Limit_OnSiteGenOnly==1:
    for row in range (len(BatteryTankMax)):
      if optimal_generation[row+(day*24)]*-1>-BatteryOutput:
        BatteryOutputmin[row]=optimal_generation[row+(day*24)]*-1

  minCons = np.concatenate((BatteryOutputmin, BatteryTankmin))
  MaxCons = np.concatenate((BatteryOutputMax, BatteryTankMax))

  minCons = np.concatenate((BatteryOutputmin, BatteryTankmin))
  MaxCons = np.concatenate((BatteryOutputMax, BatteryTankMax))

    #TankConstraints Matrix // DESIGNED FOR DAILY OPT
  TankConMa=np.zeros((24, 24))
  for row in range (0, 24):
    column=0
    while column<=row:
      TankConMa[row,column]=-1
      column+=1

  CenterMatrix = np.concatenate((np.identity(24), TankConMa))

  constraint_output=LinearConstraint(CenterMatrix,minCons,MaxCons)


  batt_opt = minimize(batteryDailySavings, tempBatteryGen, method='trust-constr', 
                      constraints = [constraint_output], args=(demand_charge,hrPrices,hrLoad), 
                      tol=1e-5, options={'maxiter':5000})
  

  vectorResult = batt_opt.x

  for counter in range(0, 24):
    BatteryOutputArray[(day * 24) + counter] = vectorResult[counter]

  InitialTank += -np.sum(vectorResult)
  
  BatteryTankmin = np.full(24,-InitialTank)
  minCons = np.concatenate((BatteryOutputmin, BatteryTankmin))
  constraint_output = LinearConstraint(CenterMatrix, minCons, MaxCons)

  print(batt_opt.message)
  print("Savings")
  print(-batteryDailySavings(vectorResult, demand_charge,hrPrices,hrLoad))
  print("")
  print("Prices")
  print(hrPrices)
  print("")
  print("Output")
  print(vectorResult)
  print("")
  
  plt.plot(df['load'].values[(day*24):24+(day*24)],label='Original Load')
  plt.plot(optimal_generation[(day*24):24+(day*24)],label='Optimal Generation')
  plt.plot(vectorResult,label='BatOutput')
  plt.plot(tempNetLoad-vectorResult,label='Net Load After Battery')
  plt.axhline(y=0, color='k',linestyle='dotted')
  plt.legend()
  plt.show()    

  plt.plot(np.dot(TankConMa,vectorResult),label='Tank')
  plt.plot(vectorResult,label='Battery Output')
  plt.grid(axis='y')
  plt.legend()
  plt.show()    

  
  plt.plot(df['kw_rate'].values[(day*24):24+(day*24)],label='kW Rate')
  plt.legend()
  plt.show()

  plt.plot(df['kwh_rate'].values[(day*24):24+(day*24)],label='kWh Rate')
  plt.legend()
  plt.show()

  print('New Initial Tank',InitialTank)

print("------------------------------------")
total_npv = -round(res.fun,2)+float(BestNPVinv)
print("Optimal PV kW= ", res.x[0])
print("Optimal Fuel Cell kW= ", res.x[1])
print("Optimal CHP kW= ", res.x[2])
print('Total Generation= ',np.sum(optimal_generation))
print('Generation NPV= ',-round(res.fun,2))
print('Battery NPV= ',float(BestNPVinv))
print("Total Net Present Value= ", total_npv)
print()













